// Brainfuck IR proposal
//
// Elemental macros
// Macros don't reqire ; at the end
// 
// #sft(#int)    series of > or <
// #in()         ,
// #out()        .
// #loop(char){} []

// count in binary forever
char a = 1;
#loop(a){
    char b;
    ^char c;// allocate to top of stack
    #loop(c){
        #sft(+1);
    }
    // now c points to 0 cell
    c++;
    #sft(-1);
    #loop(c){
        c--;
        #sft(-1);
    }
    #sft(+1);
}


fun genPrime(int n): void{
    dyn sieve: int[] = [2];
    for(var i: int = 3){

    }
}



// prime generator
fun genPrime(int n) -> void {
    dyn int[] sieve = [2];
    for(int i = 3; i < n; i++){
        int max = sqrt(i);
        for(int j = 0; j < sieve.length; j++){
            if(sieve[j] > max)break;
            if(i % sieve[j] === 0){
                sieve.push(i);
                println(i);
            }
        }
    }
    sieve.map((int value) -> int {return value * 2});
    sieve.map(value -> value * 2)
    sieve.map(fun (int value): int {return value * 2});
    someFunc(():void{

    })
    someFunc(()=>{
        
    })
}

fn asdf(int value) -> int {
    return value * 2;
}

typedef dynamicIntArray = dyn int[];

<type> <type>.methodName(){}
<type> functionName(){}
<type> variableName = <expr>
<type> 

type int = (char, char, char, char);
type int = (
    char first,
    char second,
    char third,
    char fourth,
);

int: type = (
    cahr first,
    char second,
    ...
)

class Logger{
    constructor(public target: any){}
    log(){
        print(target.toString())
    }
}

class a<T>{
    a: int;
    b: int;
    c: T;
    constructor(a, b, c){

    }
}

// Trennung zwischen Typ und Value
type aaa = (
    dynamic first: xxx
)

type a = (int)

val aaa = (
    first: char,
    second: char,
    char,
    fourth: char
)

type AAA<T> = 


operator + (a: int, b: int) -> int {

} 

operator + (int a, int b) -> int {
    int c;
    (char first, char second) anchor1 = (0, 0);
    (char first, char second) anchor2 = (0, 1);

    #loop(a.fourth){
        a.fourth--;
        c.fourth++;
        anchor1.first++;
    }
    #loop(b.fourth){
        c.fourth++;
        anchor1.first++;
        // check if c.fourth is non-zero
        char flag;
        #loop(anchor1.first){
            #seek(anchor1.first, anchor2.first);
        }
        #loop(anchor1.fourth)


        #loop(c.fourth){// non-zero
            anchor[1]++;
            #seek(c.fourth, anchor[0]);
        }
        #seek()
        // anchor if c.fourth is non-zero
        // c.fourth if zero


        #seek(zero, b.fourth)
        
    }
    #loop(c.fourth){
        b.fourth--;
        #loop(b.fourth){
            sft(zero);
        }

    }

    #loop(a.fourth){
        a.fourth--;
        c.fourth++;
    }

    #loop(b.fourth){
        b.fourth--;
        c.fourth++;
        #loop(c.fourth){
            // c is non-zero
            
        }
    }
    a.first + b.first
}


type float = (
    char first,
    char second,
    char third,
    char fourth,
);
type d3 = (float x, float y, float z);
type color = (char r, char g, char b, char a);
type int = {char, char, char, char};
fun dyn (char, char, char, char).has(){

}

typedef int (char char char char)

operator + (int v1, int v2) -> int {

}

type u8 = (
    cahr, char, char, char, char, char, char, char
    operator + (n1: u8, n2: u8): u8{
        val n = u8
    }
);


operator + ((char char char char) v1, (char char char char) v2) -> (char char char char) {

}

fn dyn int[].has

fun dyn (char char char char).has() {

}


fun dyn int[].has() -> bool {
    
}

dyn int[] dyn int[].has(){
    
}

@method(dyn int[])
dyn int[] has(){

}

dyn int[] @(dyn int[]).has(){

}

fun dyn int[].has()


function dyn int[].has(int): bool{
    
}

dyn int[] dyn int[].has

dyn int[] (dyn int[].has)(){

}


dyn int[] int[].intersection

// list intersection
dyn int[] intersection(dyn int[] l1, dyn int[] l2){
    dyn int[] l3;
    for(int i = 0; i < l1.length; i++){
        for(int j = 0; j < l2.length; j++){
            int v1 = l1[i];
            int v2 = l2[j];
            if(v1 == v2 && )

        }

    }
}



^size_t a;
^size_t b;
#loop(a){
    
    
}



// fibonacci in mett

char fib(char n){
    if(n == 1){
        return 1;
    }else if(n == 2){
        return 1;
    }else{
        return fib(n-1) + fib(n-2);
    }
}

char main(){
    cahr n = 5;
    char res = fib(n);
    #out(res);
    #out(n);
}


// now let's compile it
char exit = 1;
^char block = 0;
#loop(exit){
    if(block == 0){
        ^char n = 5;
        #out(n);
        block = 1;
    }else if(){
    }
    
}









